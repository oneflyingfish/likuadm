// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: protobuf.proto

package control

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LeaderControlClient is the client API for LeaderControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LeaderControlClient interface {
	CheckHealth(ctx context.Context, in *NoneValue, opts ...grpc.CallOption) (*HealthDescription, error)
	NodeToken(ctx context.Context, in *NoneValue, opts ...grpc.CallOption) (*TokenString, error)
	CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...grpc.CallOption) (*TokenValue, error)
	DeleteToken(ctx context.Context, in *TokenString, opts ...grpc.CallOption) (*NoneResponse, error)
	QueryTokens(ctx context.Context, in *NoneValue, opts ...grpc.CallOption) (*TokenValueList, error)
	BootStrapKubelet(ctx context.Context, in *BootStrapKubeletRequest, opts ...grpc.CallOption) (*BootStrapKubeletResponse, error)
	BootStrapNetwork(ctx context.Context, in *BootStrapNetworkRequest, opts ...grpc.CallOption) (*BootStrapNetworkResponse, error)
	BootStrapKubeProxy(ctx context.Context, in *BootStrapKubeProxyRequest, opts ...grpc.CallOption) (*BootStrapKubeProxyResponse, error)
}

type leaderControlClient struct {
	cc grpc.ClientConnInterface
}

func NewLeaderControlClient(cc grpc.ClientConnInterface) LeaderControlClient {
	return &leaderControlClient{cc}
}

func (c *leaderControlClient) CheckHealth(ctx context.Context, in *NoneValue, opts ...grpc.CallOption) (*HealthDescription, error) {
	out := new(HealthDescription)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/CheckHealth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) NodeToken(ctx context.Context, in *NoneValue, opts ...grpc.CallOption) (*TokenString, error) {
	out := new(TokenString)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/NodeToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...grpc.CallOption) (*TokenValue, error) {
	out := new(TokenValue)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/CreateToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) DeleteToken(ctx context.Context, in *TokenString, opts ...grpc.CallOption) (*NoneResponse, error) {
	out := new(NoneResponse)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/DeleteToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) QueryTokens(ctx context.Context, in *NoneValue, opts ...grpc.CallOption) (*TokenValueList, error) {
	out := new(TokenValueList)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/QueryTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) BootStrapKubelet(ctx context.Context, in *BootStrapKubeletRequest, opts ...grpc.CallOption) (*BootStrapKubeletResponse, error) {
	out := new(BootStrapKubeletResponse)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/BootStrapKubelet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) BootStrapNetwork(ctx context.Context, in *BootStrapNetworkRequest, opts ...grpc.CallOption) (*BootStrapNetworkResponse, error) {
	out := new(BootStrapNetworkResponse)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/BootStrapNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderControlClient) BootStrapKubeProxy(ctx context.Context, in *BootStrapKubeProxyRequest, opts ...grpc.CallOption) (*BootStrapKubeProxyResponse, error) {
	out := new(BootStrapKubeProxyResponse)
	err := c.cc.Invoke(ctx, "/control.LeaderControl/BootStrapKubeProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeaderControlServer is the server API for LeaderControl service.
// All implementations should embed UnimplementedLeaderControlServer
// for forward compatibility
type LeaderControlServer interface {
	CheckHealth(context.Context, *NoneValue) (*HealthDescription, error)
	NodeToken(context.Context, *NoneValue) (*TokenString, error)
	CreateToken(context.Context, *CreateTokenRequest) (*TokenValue, error)
	DeleteToken(context.Context, *TokenString) (*NoneResponse, error)
	QueryTokens(context.Context, *NoneValue) (*TokenValueList, error)
	BootStrapKubelet(context.Context, *BootStrapKubeletRequest) (*BootStrapKubeletResponse, error)
	BootStrapNetwork(context.Context, *BootStrapNetworkRequest) (*BootStrapNetworkResponse, error)
	BootStrapKubeProxy(context.Context, *BootStrapKubeProxyRequest) (*BootStrapKubeProxyResponse, error)
}

// UnimplementedLeaderControlServer should be embedded to have forward compatible implementations.
type UnimplementedLeaderControlServer struct {
}

func (UnimplementedLeaderControlServer) CheckHealth(context.Context, *NoneValue) (*HealthDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckHealth not implemented")
}
func (UnimplementedLeaderControlServer) NodeToken(context.Context, *NoneValue) (*TokenString, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeToken not implemented")
}
func (UnimplementedLeaderControlServer) CreateToken(context.Context, *CreateTokenRequest) (*TokenValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateToken not implemented")
}
func (UnimplementedLeaderControlServer) DeleteToken(context.Context, *TokenString) (*NoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteToken not implemented")
}
func (UnimplementedLeaderControlServer) QueryTokens(context.Context, *NoneValue) (*TokenValueList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTokens not implemented")
}
func (UnimplementedLeaderControlServer) BootStrapKubelet(context.Context, *BootStrapKubeletRequest) (*BootStrapKubeletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BootStrapKubelet not implemented")
}
func (UnimplementedLeaderControlServer) BootStrapNetwork(context.Context, *BootStrapNetworkRequest) (*BootStrapNetworkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BootStrapNetwork not implemented")
}
func (UnimplementedLeaderControlServer) BootStrapKubeProxy(context.Context, *BootStrapKubeProxyRequest) (*BootStrapKubeProxyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BootStrapKubeProxy not implemented")
}

// UnsafeLeaderControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeaderControlServer will
// result in compilation errors.
type UnsafeLeaderControlServer interface {
	mustEmbedUnimplementedLeaderControlServer()
}

func RegisterLeaderControlServer(s grpc.ServiceRegistrar, srv LeaderControlServer) {
	s.RegisterService(&LeaderControl_ServiceDesc, srv)
}

func _LeaderControl_CheckHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoneValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).CheckHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/CheckHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).CheckHealth(ctx, req.(*NoneValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_NodeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoneValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).NodeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/NodeToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).NodeToken(ctx, req.(*NoneValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_CreateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).CreateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/CreateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).CreateToken(ctx, req.(*CreateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_DeleteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).DeleteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/DeleteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).DeleteToken(ctx, req.(*TokenString))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_QueryTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoneValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).QueryTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/QueryTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).QueryTokens(ctx, req.(*NoneValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_BootStrapKubelet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootStrapKubeletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).BootStrapKubelet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/BootStrapKubelet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).BootStrapKubelet(ctx, req.(*BootStrapKubeletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_BootStrapNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootStrapNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).BootStrapNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/BootStrapNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).BootStrapNetwork(ctx, req.(*BootStrapNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderControl_BootStrapKubeProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootStrapKubeProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderControlServer).BootStrapKubeProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/control.LeaderControl/BootStrapKubeProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderControlServer).BootStrapKubeProxy(ctx, req.(*BootStrapKubeProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LeaderControl_ServiceDesc is the grpc.ServiceDesc for LeaderControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeaderControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "control.LeaderControl",
	HandlerType: (*LeaderControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckHealth",
			Handler:    _LeaderControl_CheckHealth_Handler,
		},
		{
			MethodName: "NodeToken",
			Handler:    _LeaderControl_NodeToken_Handler,
		},
		{
			MethodName: "CreateToken",
			Handler:    _LeaderControl_CreateToken_Handler,
		},
		{
			MethodName: "DeleteToken",
			Handler:    _LeaderControl_DeleteToken_Handler,
		},
		{
			MethodName: "QueryTokens",
			Handler:    _LeaderControl_QueryTokens_Handler,
		},
		{
			MethodName: "BootStrapKubelet",
			Handler:    _LeaderControl_BootStrapKubelet_Handler,
		},
		{
			MethodName: "BootStrapNetwork",
			Handler:    _LeaderControl_BootStrapNetwork_Handler,
		},
		{
			MethodName: "BootStrapKubeProxy",
			Handler:    _LeaderControl_BootStrapKubeProxy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf.proto",
}
